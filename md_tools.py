import os
import logging

import yaml
import uuid
import subprocess
import datetime
from typing import Any, cast, TypedDict

from ebook_utils import sanitized_md_filename, progress_bar_string


class MDTable(TypedDict):
    columns: list[str]
    rows: list[list[str]]
    metadata: dict[str, Any]  # pyright: ignore[reportExplicitAny]
    note_uuid: str
             

class MdTools:
    """Class to manage the markdown folder of book records

    These markdown files have been generated by the calibre_tools export function.
    """

    def __init__(
        self,
        notes_folder: str,
        notes_books_folder: str,
        notes_annotations_folder: str = "",
        skip_dirs: list[str] | None = None,
        progress: bool = False,
        dry_run: bool = False,
    ):
        if skip_dirs is None or len(skip_dirs) == 0:
            skip_dirs = [".obsidian", "Templates", "Templater"]
        self.log: logging.Logger = logging.getLogger("MdTools")
        self.dry_run: bool = dry_run
        self.notes_folder: str = notes_folder
        if notes_books_folder == "":
            notes_books_folder = os.path.join(notes_folder, "Books")
        if notes_annotations_folder == "":
            notes_annotations_folder = os.path.join(notes_folder, "BookNotes")
        self.notes_books_folder: str = notes_books_folder
        self.notes_annotations_folder: str = notes_annotations_folder
        self.skip_dirs: list[str] = skip_dirs
        if not os.path.exists(self.notes_folder):
            raise FileNotFoundError(f"Notes folder {self.notes_folder} does not exist")
        if not os.path.exists(self.notes_books_folder):
            os.makedirs(self.notes_books_folder)
            self.log.info(f"Created folder {self.notes_books_folder}")
        if not os.path.exists(self.notes_annotations_folder):
            os.makedirs(self.notes_annotations_folder)
            self.log.info(f"Created folder {self.notes_annotations_folder}")
        self.progress: bool = progress
        self.read_notes(skip_dirs=skip_dirs, progress=progress)

    def parse_frontmatter(self, txt:str) -> tuple[dict[str, Any], str]:  # pyright: ignore[reportExplicitAny]
        state:int = 0
        lines: list[str] = txt.split("\n")
        frontmatter_lines: list[str] = []
        frontmatter: str = ""
        content_lines: list[str] = []
        content: str = ""
        start = True
        for line in lines:
            if state == 0:
                if line == "---" and start is True:
                    state = 1
                else:
                    content_lines.append(line)
                start = False
            elif state == 1:
                if line == "---":
                    state = 2
                else:
                    frontmatter_lines.append(line)
            elif state == 2:
                if len(content_lines) == 0:
                    if line == "":
                        continue
                content_lines.append(line)
        frontmatter = "\n".join(frontmatter_lines)  # + "\n"
        content = "\n".join(content_lines) + "\n"
        try:
            metadata: dict[Any, Any] = yaml.safe_load(frontmatter)  # pyright: ignore[reportExplicitAny]
        except Exception as e:
            self.log.error(f"Error parsing frontmatter: {e}")
            metadata = {}
        return metadata, content

    def assemble_markdown(self, metadata: dict[str, Any], content: str) -> str:  # pyright: ignore[reportExplicitAny]
        if metadata  == {}:
            return content
        header = yaml.dump(metadata, default_flow_style=False, indent=2)
        return f"---\n{header}---\n{content}"

    def note_cache_links(self, note: dict[str, Any]) -> list[str]:  # pyright: ignore[reportExplicitAny]
        links: list[str] = []
        if "content" in note:
            content: str = str(note["content"])  # pyright: ignore[reportAny]
            for line in content.split("\n"):
                # Find links of format [[link]] or [[link|alias]]
                ind = line.find("[[")
                while ind >= 0:
                    ind2a = line.find("]]", ind)
                    ind2b = line.find("|", ind)
                    if ind2a <= 0:
                        ind = line.find("[[", ind + 2)
                        continue
                    if ind2b > 0 and ind2b < ind2a:
                        ind2 = ind2b
                    else:
                        ind2 = ind2a
                    link = line[ind + 2 : ind2].strip().lower()
                    links.append(link)
                    ind = line.find("[[", ind2)
            note["links"] = links
        return links

    def _note_get_file_creation_date_from_git(self, filepath: str) -> datetime.datetime | None:
        try:
            creation_date = subprocess.check_output(
                args = [
                    "git",
                    "-C",
                    self.notes_folder,
                    "--no-pager",
                    "log",
                    "--follow",
                    "--format=%aI",
                    "--reverse",
                    filepath,
                ]
            )
            cr_date = creation_date.decode("utf-8").split("\n")[0]
            # datetime parse:
            try:
                dt = datetime.datetime.strptime(cr_date, "%Y-%m-%dT%H:%M:%S%z")
                return dt
            except Exception as e:
                self.log.debug(
                    f"Error file {filepath}, failed parsing date {cr_date}: {e}"
                )
                return None
        except Exception as _:
            return None

    def _note_get_file_modification_date(self, filepath: str) -> datetime.datetime | None:
        try:
            stat = os.stat(filepath)
            dt = datetime.datetime.fromtimestamp(stat.st_mtime)
            return dt
        except Exception as e:
            self.log.warning(f"Error getting file modification date {filepath}: {e}")
            return None

    def get_note_creation_date(self, filepath: str) -> datetime.datetime | None:
        dt_git: datetime.datetime | None = self._note_get_file_creation_date_from_git(filepath)
        dt_stat = self._note_get_file_modification_date(filepath)
        # self.log.info(f"Creation date for {filepath} from git: {dt_git}, from stat: {dt_stat}")
        if dt_git is not None:
            return dt_git
        if dt_stat is not None:
            return dt_stat
        return None
    
    def minimal_frontmatter(self, note: dict[str, Any], filename: str) -> int:  # pyright: ignore[reportExplicitAny]
        changed = 0
        if "metadata" not in note:
            note["metadata"] = {}
            self.log.info(f"Note {filename} had no metadata, adding...")
            changed += 1
        if "uuid" not in note["metadata"]:
            note["metadata"]["uuid"] = str(uuid.uuid4())
            self.log.info(
                f"Note {filename} had no UUID, adding {note['metadata']['uuid']}"
            )
            changed += 1
        if "creation" not in note["metadata"]:
            dt = self.get_note_creation_date(filename)
            if dt is not None:
                note["metadata"]["creation"] = dt.isoformat()
                changed += 1
                self.log.info(f"Note {filename} had no creation date, adding {dt}")
            else:
                self.log.error(f"Error getting creation date for {filename}")
        relative_folder = os.path.relpath(os.path.dirname(filename), self.notes_folder)
        if "context" not in note["metadata"]:
            note["metadata"]["context"] = relative_folder
            changed += 1
            self.log.info(f"Note {filename} had no context, adding {relative_folder}")
        else:
            if relative_folder == "Books":
                if "tags" in note["metadata"]:
                    tags: list[str] = cast(list[str], note["metadata"]["tags"])
                    for tag in tags:
                        if tag.startswith("Series/"):
                            relative_folder: str = "Books/" + tag[7:]
                            break
            if note["metadata"]["context"] != relative_folder:
                note["metadata"]["context"] = relative_folder
                self.log.info(f"Note {filename} context changed to {relative_folder}")
                changed += 1
        return changed

    # Look for tables in markdown content. The last comment before the table can contain metadata
    # in fxsorm: `<!-- key1: value1; key2: value2; ... -->`
    # Returns a dict with tables, each table is a dict with columns and data and metadata
    ### XXX Frickel-Parser!
    def parse_tables(self, content: str, filepath:str, note_uuid:str | None=None) -> list[MDTable]:
        tables: list[MDTable] = []
        lines: list[str] = content.split("\n")
        table_state = 0
        rows: list[list[str]] = []
        columns: list[str] = []
        metadata: dict[str, Any] = {}  # pyright: ignore[reportExplicitAny]
        for line in lines:
            line = line.strip()
            # XXX sloppy parser, fails on ;: at wrong places!
            if "<!--" in line:
                metadata = {}
                try:
                    meta = line.split("<!--")[1].split("-->")[0]
                except Exception as _:
                    meta = ""
                if len(meta) > 0:
                    metas = [mt.strip() for mt in meta.split(";")]
                    for mt in metas:
                        key = None
                        value = None
                        if ":" in mt:
                            try:
                                key, value = mt.split(":", 1)
                                key = key.strip()
                                value = value.strip()
                                if value.startswith('"') and value.endswith('"'):
                                    value = value[1:-1]
                                metadata[key] = value
                            except Exception as _:
                                pass

            if table_state == 0:
                if line.startswith("```"):
                    if line.lower().startswith("```indraevent"):
                        columns = []
                        rows = []
                        table_state = 6
                    else:
                        columns = []
                        rows = []
                        table_state = 4
                    continue
                if line.startswith("$$"):  # start of latex block
                    table_state = 5
                    columns = []
                    rows = []
                    continue
                if line.startswith("|"):
                    if not line.endswith("|"):
                        self.log.warning(
                            f"Table line does not end with '|', >{line}<, malformed tabled! Ignoring data."
                        )
                        return tables
                    table_state = 1
                    columns = [col.strip() for col in line[1:].split("|")][:-1]
                    rows = []
                    continue
            elif table_state == 1:
                if line.startswith("|"):
                    for c in line:
                        if c not in ["|", " ", "-", ":", ">", "<"]:
                            table_state = 0
                            columns = []
                            rows = []
                            metadata = {}
                            continue
                    table_state = 2
                    continue
                else:
                    columns = []
                    rows = []
                    metadata = {}
                    table_state = 0
                    continue
            elif table_state == 2:
                if line.startswith("|"):
                    row = [col.strip() for col in line[1:].split("|")][:-1]
                    if len(row)>0 and row[0] == "Date":
                        print(f"Bad line in middle of table: {line}")
                    rows.append(row)
                    continue
                else:
                    table_state = 0
                    subfolders = None
                    # Strip extension from filepath
                    filepath_noext = os.path.splitext(filepath)[0]
                    if filepath_noext.startswith(self.notes_folder):
                        subfolders = filepath_noext[len(self.notes_folder) + 1 :]
                        if len(columns) > 1 and columns[0] == "Date":
                            subfolders = f"{subfolders}/{columns[1]}"
                            bad_chars = [
                                " ",
                                "#",
                                "+",
                                "$",
                                ".",
                                ",",
                                ":",
                            ]
                            for bc in bad_chars:
                                subfolders = subfolders.replace(bc, "_")
                            elim_chars = ["*"]
                            for ec in elim_chars:
                                subfolders = subfolders.replace(ec, "")
                            subfolders = subfolders.replace("__", "_")
                            if subfolders.endswith("_"):
                                subfolders = subfolders[:-1]
                        else:
                            subfolders = None
                    else:
                        self.log.error(
                            f"Unexpected filepath {filepath} not in notes folder {self.notes_folder}"
                        )
                        subfolders = None
                    if len(rows) > 0:
                        if "domain" not in metadata and subfolders is not None:
                            metadata["domain"] = f"{subfolders}"
                        # if len(metadata.keys()) > 0:
                        #     print(f"Table metadata: {metadata}")
                        if note_uuid is None:
                            note_uuid = ""
                        table_entry: MDTable = {
                            "columns": columns,
                            "rows": rows,
                            "metadata": metadata,
                            "note_uuid": note_uuid
                        }
                        tables.append(table_entry)
                    rows = []
                    columns = []
                    metadata = {}
                    continue
            elif table_state == 4:
                if line.startswith("```"):
                    table_state = 0
                    rows = []
                    columns = []
                    metadata = {}
                    continue
            elif table_state == 5:
                if line.startswith("$$"):  # end of latex block
                    table_state = 0
                    rows = []
                    columns = []
                    metadata = {}
                    continue
            elif table_state == 6:
                if line.startswith("```"):
                    table_state = 0
                    rows = []
                    columns = []
                    metadata = {}
                else:
                    meta = line.split("=", 1)
                    if len(meta) == 2:
                        key = meta[0].strip()
                        val = meta[1].strip()
                        if val.startswith('"') and val.endswith('"'):
                            val = val[1:-1]
                        metadata[key] = val
                continue
        return tables

    def read_md_file(self, filename: str) -> dict[str, Any]:  # pyright: ignore[reportExplicitAny]
        note: dict[str, Any] = {}  # pyright: ignore[reportExplicitAny]
        with open(filename, "r") as f:
            note_text = f.read()
            changed = 0
            note["changes"] = changed
            note["metadata"], note["content"] = self.parse_frontmatter(note_text)
            meta_changes = self.minimal_frontmatter(note, filename)
            # if meta_changes > 0:
            #     self.log.info(f"Minimal frontmatter changes added to {filename}: {note['metadata']}")
            note["changes"] += meta_changes
            if "uuid" in note["metadata"]:
                note_uuid: str = note["metadata"]["uuid"]
            else:
                note_uuid = ""
            note["tables"] = self.parse_tables(note["content"], filename, note_uuid)
            _ = self.note_cache_links(note)
            if note["changes"] > 0:
                _ = self.write_note(filename, note)
        return note

    def register_note(self, note_filename: str, note: dict[str, Any]):  # pyright: ignore[reportExplicitAny]
        note_file_title = os.path.basename(note_filename)[:-3].lower()
        if note_file_title in self.note_file_title_to_filename:
            self.log.error(
                f"Duplicate note basename {note_file_title} encountered at {note_filename}, ignoring note, please rename!"
            )
            return
        if "metadata" in note and "uuid" in note["metadata"]:
            uuid:str = note["metadata"]["uuid"]
            if uuid in self.uuid_to_note_filename:
                self.log.error(
                    f"Duplicate uuid {uuid} encountered at {note_filename}, ignoring note, please make UUID unique!"
                )
                return
            self.uuid_to_note_filename[uuid] = note_filename
        self.note_file_title_to_filename[note_file_title] = note_filename
        self.notes[note_filename] = note

    def write_note(self, filename: str, note: dict[str, Any]) -> bool:  # pyright: ignore[reportExplicitAny]
        if "metadata" not in note:
            self.log.error(f"Note {filename} has no metadata")
            return False
        if "content" not in note:
            self.log.error(f"Note {filename} has no content")
            return False
        note_reassembled = self.assemble_markdown(note["metadata"], note["content"])  # pyright: ignore[reportAny]
        if self.dry_run is False:
            with open(filename, "w") as f:
                _ = f.write(note_reassembled)
            self.log.info(f"Note {filename} written")
        else:
            self.log.warning(f"Dry run: Note {filename} would be written")
        return True

    def read_notes(self, skip_dirs: list[str], progress: bool = False):
        self.notes: dict[str, Any] = {}  # pyright: ignore[reportExplicitAny]
        self.uuid_to_note_filename: dict[str, str] = {}
        self.note_file_title_to_filename: dict[str, str] = {}

        notes_count = 0
        if progress is True:
            for root, dirs, files in os.walk(self.notes_folder):
                for skip_dir in skip_dirs:
                    if skip_dir in dirs:
                        dirs.remove(skip_dir)
                for file in files:
                    if file.endswith(".md"):
                        notes_count += 1
            if notes_count == 0:
                self.log.info("No markdown notes found")
                return
        notes_progress = 0
        num = 0
        for root, dirs, files in os.walk(self.notes_folder):
            for skip_dir in skip_dirs:
                if skip_dir in dirs:
                    dirs.remove(skip_dir)
            for file in files:
                num += 1
                if file.endswith(".md"):
                    if progress is True:
                        notes_progress += 1
                        progress_str = progress_bar_string(
                            notes_progress, notes_count, bar_length=20
                        )
                        print(
                            f"\r{progress_str} {notes_progress}/{notes_count}", end=""
                        )

                    note_filename = os.path.join(root, file)
                    note = self.read_md_file(note_filename)
                    self.register_note(note_filename, note)

        self.log.info(f"Found {len(self.notes)} existing markdown notes")
        return

    def rename_note(
        self, current_filename: str, new_filename: str, update_links: bool = True, dry_run: bool = False
    ) -> int:
        if current_filename not in self.notes:
            self.log.error(f"Note {current_filename} not found")
            return 0
        note = self.notes[current_filename]
        if new_filename in self.notes:
            self.log.error(f"Note {new_filename} already exists")
            return 0
        self.notes[new_filename] = note
        if dry_run is False:
            del self.notes[current_filename]
            os.rename(current_filename, new_filename)
            self.log.info(f"Note {current_filename} renamed to {new_filename}")
        else:
            self.log.info(
                f"Dry run: Note {current_filename} would be renamed to {new_filename}"
            )
        content_updates = 0
        if update_links is True:
            # Update links of format [[old_link]] or [[old_link|alias]] using regex links are case-insensitive
            old_link = os.path.basename(current_filename)[:-3].lower()
            new_link = os.path.basename(new_filename)[:-3]

            for note_filename in self.notes:
                note: dict[str, Any] = self.notes[note_filename]  # pyright: ignore[reportExplicitAny]
                if "content" in note:
                    content: str = note["content"]
                    new_content: list[str] = []
                    note_updated = False
                    for line in content.split("\n"):
                        test_line = line.lower()
                        ind1 = test_line.find("[[")
                        if ind1 >= 0:
                            while ind1 >= 0:
                                ind2a = test_line.find("]]", ind1)
                                ind2b = test_line.find("|", ind1)
                                if ind2a <= 0:
                                    ind1 = test_line.find("[[", ind1 + 2)
                                    continue
                                if ind2b > 0 and ind2b < ind2a:
                                    ind2 = ind2b
                                else:
                                    ind2 = ind2a
                                link = test_line[ind1 + 2 : ind2].strip()
                                if link == old_link:
                                    self.log.info(
                                        f"Found link {link} in {note_filename}"
                                    )
                                    new_line = (
                                        line[:ind1] + "[[" + new_link + line[ind2:]
                                    )
                                    line = new_line
                                    test_line = line.lower()
                                    ind2 = ind1 + len(new_link) + 4
                                    note_updated = True
                                    if dry_run is False:
                                        self.log.info(
                                            f"Changed link {link} to {new_link} in {note_filename}:"
                                        )
                                        self.log.info(f"  {line} -> {new_line}")
                                    else:
                                        self.log.info(
                                            f"WOULD Change link {link} to {new_link} in {note_filename}:"
                                        )
                                        self.log.info(f"  {line} -> {new_line}")
                                ind1 = test_line.find("[[", ind2)
                            new_content.append(line)
                        else:
                            new_content.append(line)
                    if note_updated is True:
                        content_updates += 1
                        note["content"] = "\n".join(new_content) + "\n"
                        _ = self.note_cache_links(note)
                        _ = self.write_note(note_filename, note)
        return content_updates

    def md_filename(self, name: str):
        name = sanitized_md_filename(name)
        md_book_note_filename = os.path.join(self.notes_books_folder, name + ".md")
        return md_book_note_filename

    def md_annotation_filename(self, name: str):
        name = sanitized_md_filename(name)
        annotations_filename = os.path.join(
            self.notes_annotations_folder, "Notes on " + name
        )
        return annotations_filename

    @staticmethod
    def gen_markdown_header(clip: dict[str, Any]) -> str:  # pyright: ignore[reportExplicitAny]
        md = ""
        md += f"# Notes on {clip['title']}\n\n"
        md += f"_by {clip['author']}_\n\n"
        ref = os.path.basename(cast(str, clip["md_filename"]))[:-3]
        ref = ref.split(",")[0]
        md += f"see [[{ref}]]\n\n"
        if clip["warning"] is not None:
            md += f"Warning: {clip['warning']}\n\n"
        return md

    def markdownify_clips(self, clips:list[dict[str, Any]]):  # pyright: ignore[reportExplicitAny]
        md = ""
        for clip in clips:
            hd = MdTools.gen_markdown_header(clip)
            clip_filename: str = clip['notes_filename']
            if os.path.exists(clip_filename):
                print(f"File {clip_filename} already exists")
                with open(clip_filename, "r") as f:
                    md = f.read()
                if hd not in md:
                    print(
                        f"Incompatible notes header for {clip['notes_filename']}, keeping old header!"
                    )
                is_existing = True
            else:
                md = hd
                is_existing = False
            if "page" in clip and clip["page"] is not None:
                sub_header = f"### {clip['type']} on page {clip['page']}\n\n"
            else:
                sub_header = f"### {clip['type']} at location {clip['location']}\n\n"
            if is_existing and sub_header in md:
                print(f"Entry {sub_header} already exists in {clip['notes_filename']}")
                continue

            md += sub_header
            md += f"_on {clip['date']}:_\n\n"
            md += f"> {clip['content']}\n\n"
            with open(clip_filename, "w") as f:
                _ = f.write(md)
