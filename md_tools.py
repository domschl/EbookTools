import os
import logging
from ebook_utils import sanitized_md_filename


class MdTools:
    """Class to manage the markdown folder of book records

    These markdown files have been generated by the calibre_tools export function.
    """

    def __init__(self, notes_books_folder, notes_annotations_folder):
        self.log = logging.getLogger("MdTools")
        self.notes_books_folder = notes_books_folder
        self.notes_annotations_folder = notes_annotations_folder

    def get_books(self):
        self.books = []
        for root, dirs, files in os.walk(self.notes_books_folder):
            for file in files:
                if file.endswith(".md"):
                    self.books.append(os.path.join(root, file))
        self.log.info(f"Found {len(self.books)} existing markdown notes on books")
        return self.books

    def md_filename(self, name):
        name = sanitized_md_filename(name)
        md_book_note_filename = os.path.join(self.notes_books_folder, name + ".md")
        return md_book_note_filename

    def md_annotation_filename(self, name):
        name = sanitized_md_filename(name)
        annotations_filename = os.path.join(
            self.notes_annotations_folder, "Notes on " + name
        )
        return annotations_filename

    def match_md_note_filename(self, md_book_note_filename):
        for book in self.books:
            if md_book_note_filename == book:
                self.log.info(f"exact match: {md_book_note_filename}")
                return md_book_note_filename
        # for book in self.books:
        #     if (
        #         md_note_filename[:-3] == book[: len(md_note_filename[:-3])]
        #         or md_note_filename[: len(book[:-3])] == book[:-3]
        #     ):
        #         self.log.info(
        #             f"Warning: Book filename {md_note_filename} does not match {book} exactly"
        #         )
        #         return book
        self.log.info(f"no match: {md_book_note_filename}")
        return None

    @staticmethod
    def gen_markdown_header(clip):
        md = ""
        md += f"# Notes on {clip['title']}\n\n"
        md += f"_by {clip['author']}_\n\n"
        ref = os.path.basename(clip["md_filename"])[:-3]
        ref = ref.split(",")[0]
        md += f"see [[{ref}]]\n\n"
        if clip["warning"] is not None:
            md += f"Warning: {clip['warning']}\n\n"
        return md

    def markdownify_clips(self, clips):
        md = ""
        for clip in clips:
            hd = MdTools.gen_markdown_header(clip)
            if os.path.exists(clip["notes_filename"]):
                print(f"File {clip['notes_filename']} already exists")
                with open(clip["notes_filename"], "r") as f:
                    md = f.read()
                if hd not in md:
                    print(
                        f"Incompatible notes header for {clip['notes_filename']}, keeping old header!"
                    )
                is_existing = True
            else:
                md = hd
                is_existing = False
            if "page" in clip and clip["page"] is not None:
                sub_header = f"### {clip['type']} on page {clip['page']}\n\n"
            else:
                sub_header = f"### {clip['type']} at location {clip['location']}\n\n"
            if is_existing and sub_header in md:
                print(f"Entry {sub_header} already exists in {clip['notes_filename']}")
                continue

            md += sub_header
            md += f"_on {clip['date']}:_\n\n"
            md += f"> {clip['content']}\n\n"
            with open(clip["notes_filename"], "w") as f:
                f.write(md)
