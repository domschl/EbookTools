import os
import logging

import yaml  # type: ignore
import uuid
import subprocess  # type: ignore
import datetime

from ebook_utils import sanitized_md_filename, progress_bar_string


class MdTools:
    """Class to manage the markdown folder of book records

    These markdown files have been generated by the calibre_tools export function.
    """

    def __init__(
        self,
        notes_folder,
        notes_books_folder=None,
        notes_annotations_folder=None,
        skip_dirs=[".obsidian", "Templates", "Templater"],
        progress=False,
        dry_run=False,
    ):
        self.log = logging.getLogger("MdTools")
        self.dry_run = dry_run
        self.notes_folder = notes_folder
        if notes_books_folder is None:
            notes_books_folder = os.path.join(notes_folder, "Books")
        if notes_annotations_folder is None:
            notes_annotations_folder = os.path.join(notes_folder, "BookNotes")
        self.notes_books_folder = notes_books_folder
        self.notes_annotations_folder = notes_annotations_folder
        self.skip_dirs = skip_dirs
        if not os.path.exists(self.notes_folder):
            raise FileNotFoundError(f"Notes folder {self.notes_folder} does not exist")
        if not os.path.exists(self.notes_books_folder):
            os.makedirs(self.notes_books_folder)
            self.log.info(f"Created folder {self.notes_books_folder}")
        if not os.path.exists(self.notes_annotations_folder):
            os.makedirs(self.notes_annotations_folder)
            self.log.info(f"Created folder {self.notes_annotations_folder}")
        self.progress = progress
        self.read_notes(skip_dirs=skip_dirs, progress=progress)

    def parse_frontmatter(self, txt):
        state = 0
        lines = txt.split("\n")
        frontmatter = []
        content = []
        start = True
        for line in lines:
            if state == 0:
                if line == "---" and start is True:
                    state = 1
                else:
                    content.append(line)
                start = False
            elif state == 1:
                if line == "---":
                    state = 2
                else:
                    frontmatter.append(line)
            elif state == 2:
                if len(content) == 0:
                    if line == "":
                        continue
                content.append(line)
        frontmatter = "\n".join(frontmatter)  # + "\n"
        content = "\n".join(content) + "\n"
        try:
            metadata = yaml.safe_load(frontmatter)
            if metadata is None:
                metadata = {}
        except Exception as e:
            self.log.error(f"Error parsing frontmatter: {e}")
            metadata = {}
        return metadata, content

    def assemble_markdown(self, metadata, content):
        if metadata is None or metadata == {}:
            return content
        header = yaml.dump(metadata, default_flow_style=False, indent=2)
        return f"---\n{header}---\n{content}"

    def note_cache_links(self, note):
        links = []
        if "content" in note:
            content = note["content"]
            for line in content.split("\n"):
                # Find links of format [[link]] or [[link|alias]]
                ind = line.find("[[")
                while ind >= 0:
                    ind2a = line.find("]]", ind)
                    ind2b = line.find("|", ind)
                    if ind2a <= 0:
                        ind = line.find("[[", ind + 2)
                        continue
                    if ind2b > 0 and ind2b < ind2a:
                        ind2 = ind2b
                    else:
                        ind2 = ind2a
                    link = line[ind + 2 : ind2].strip().lower()
                    links.append(link)
                    ind = line.find("[[", ind2)
            note["links"] = links
        return links

    def _note_get_file_creation_date_from_git(self, filepath):
        try:
            creation_date = subprocess.check_output(
                [
                    "git",
                    "-C",
                    self.notes_folder,
                    "--no-pager",
                    "log",
                    "--follow",
                    "--format=%aI",
                    "--reverse",
                    filepath,
                ]
            )
            cr_date = creation_date.decode("utf-8").split("\n")[0]
            # datetime parse:
            try:
                dt = datetime.datetime.strptime(cr_date, "%Y-%m-%dT%H:%M:%S%z")
                return dt
            except Exception as e:
                self.log.debug(
                    f"Error file {filepath}, failed parsing date {cr_date}: {e}"
                )
                return None
        except Exception as _:
            return None

    def _note_get_file_modification_date(self, filepath):
        try:
            stat = os.stat(filepath)
            dt = datetime.datetime.fromtimestamp(stat.st_mtime)
            return dt
        except Exception as e:
            self.log.warning(f"Error getting file modification date {filepath}: {e}")
            return None

    def get_note_creation_date(self, filepath):
        dt_git = self._note_get_file_creation_date_from_git(filepath)
        dt_stat = self._note_get_file_modification_date(filepath)
        # self.log.info(f"Creation date for {filepath} from git: {dt_git}, from stat: {dt_stat}")
        if dt_git is not None:
            return dt_git
        if dt_stat is not None:
            return dt_stat
        return None

    def minimal_frontmatter(self, note, filename):
        changed = 0
        if "metadata" not in note:
            note["metadata"] = {}
            self.log.info(f"Note {filename} had no metadata, adding...")
            changed += 1
        if "uuid" not in note["metadata"]:
            note["metadata"]["uuid"] = str(uuid.uuid4())
            self.log.info(
                f"Note {filename} had no UUID, adding {note['metadata']['uuid']}"
            )
            changed += 1
        if "creation" not in note["metadata"]:
            dt = self.get_note_creation_date(filename)
            if dt is not None:
                note["metadata"]["creation"] = dt.isoformat()
                changed += 1
                self.log.info(f"Note {filename} had no creation date, adding {dt}")
            else:
                self.log.error(f"Error getting creation date for {filename}")
        relative_folder = os.path.relpath(os.path.dirname(filename), self.notes_folder)
        if "context" not in note["metadata"]:
            note["metadata"]["context"] = relative_folder
            changed += 1
            self.log.info(f"Note {filename} had no context, adding {relative_folder}")
        else:
            if relative_folder == "Books":
                if "tags" in note["metadata"]:
                    for tag in note["metadata"]["tags"]:
                        if tag.startswith("Series/"):
                            relative_folder = "Books/" + tag[7:]
                            break
            if note["metadata"]["context"] != relative_folder:
                note["metadata"]["context"] = relative_folder
                self.log.info(f"Note {filename} context changed to {relative_folder}")
                changed += 1
        return changed

    # Look for tables in markdown content. The last comment before the table can contain metadata
    # in fxsorm: `<!-- key1: value1; key2: value2; ... -->`
    # Returns a dict with tables, each table is a dict with columns and data and metadata
    ### XXX Frickel-Parser!
    def parse_tables(self, content, filepath, note_uuid=None):
        tables = []
        lines = content.split("\n")
        table_state = 0
        rows = []
        columns = []
        metadata = {}
        for line in lines:
            line = line.strip()
            # XXX sloppy parser, fails on ;: at wrong places!
            if "<!--" in line:
                metadata = {}
                try:
                    meta = line.split("<!--")[1].split("-->")[0]
                except Exception as _:
                    meta = ""
                if len(meta) > 0:
                    metas = [mt.strip() for mt in meta.split(";")]
                    for mt in metas:
                        key = None
                        value = None
                        if ":" in mt:
                            try:
                                key, value = mt.split(":", 1)
                                key = key.strip()
                                value = value.strip()
                                if value.startswith('"') and value.endswith('"'):
                                    value = value[1:-1]
                                metadata[key] = value
                            except Exception as _:
                                pass

            if table_state == 0:
                if line.startswith("```"):
                    if line.lower().startswith("```indraevent"):
                        table_state = 6
                    else:
                        table_state = 4
                    continue
                if line.startswith("$$"):  # start of latex block
                    table_state = 5
                    continue
                if line.startswith("|"):
                    if not line.endswith("|"):
                        self.log.warning(
                            f"Table line does not end with '|', >{line}<, malformed tabled! Ignoring data."
                        )
                        return tables
                    table_state = 1
                    columns = [col.strip() for col in line[1:].split("|")][:-1]
            elif table_state == 1:
                if line.startswith("|"):
                    for c in line:
                        if c not in ["|", " ", "-", ":", ">", "<"]:
                            table_state = 0
                            columns = []
                            rows = []
                            metadata = {}
                            continue
                    table_state = 2
                else:
                    columns = []
                    rows = []
                    metadata = {}
                    table_state = 0
            elif table_state == 2:
                if line.startswith("|"):
                    rows.append([col.strip() for col in line[1:].split("|")][:-1])
                else:
                    table_state = 0
                    subfolders = None
                    # Strip extension from filepath
                    filepath_noext = os.path.splitext(filepath)[0]
                    if filepath_noext.startswith(self.notes_folder):
                        subfolders = filepath_noext[len(self.notes_folder) + 1 :]
                        if len(columns) > 1 and columns[0] == "Date":
                            subfolders = f"{subfolders}/{columns[1]}"
                            bad_chars = [
                                " ",
                                "#",
                                "+",
                                "$",
                                ".",
                                ",",
                                ":",
                            ]
                            for bc in bad_chars:
                                subfolders = subfolders.replace(bc, "_")
                            elim_chars = ["*"]
                            for ec in elim_chars:
                                subfolders = subfolders.replace(ec, "")
                            subfolders.replace("__", "_")
                            if subfolders.endswith("_"):
                                subfolders = subfolders[:-1]
                        else:
                            subfolders = None
                    else:
                        self.log.error(
                            f"Unexpected filepath {filepath} not in notes folder {self.notes_folder}"
                        )
                        subfolders = None
                    if len(rows) > 0:
                        if "domain" not in metadata and subfolders is not None:
                            metadata["domain"] = f"{subfolders}"
                        # if len(metadata.keys()) > 0:
                        #     print(f"Table metadata: {metadata}")
                        table_entry = {
                            "columns": columns,
                            "rows": rows,
                            "metadata": metadata,
                        }
                        if note_uuid is not None:
                            table_entry["note_uuid"] = note_uuid
                        tables.append(table_entry)
                    rows = []
                    columns = []
                    metadata = {}
            elif table_state == 4:
                if line.startswith("```"):
                    table_state = 0
            elif table_state == 5:
                if line.startswith("$$"):  # end of latex block
                    table_state = 0
            elif table_state == 6:
                if line.startswith("```"):
                    table_state = 0
                else:
                    meta = line.split("=", 1)
                    if len(meta) == 2:
                        key = meta[0].strip()
                        val = meta[1].strip()
                        if val.startswith('"') and val.endswith('"'):
                            val = val[1:-1]
                        metadata[key] = val
        return tables

    def read_md_file(self, filename):
        with open(filename, "r") as f:
            note_text = f.read()
            changed = 0
            note = {}
            note["changes"] = changed
            note["metadata"], note["content"] = self.parse_frontmatter(note_text)
            meta_changes = self.minimal_frontmatter(note, filename)
            # if meta_changes > 0:
            #     self.log.info(f"Minimal frontmatter changes added to {filename}: {note['metadata']}")
            note["changes"] += meta_changes
            if "uuid" in note["metadata"]:
                note_uuid = note["metadata"]["uuid"]
            else:
                note_uuid = None
            note["tables"] = self.parse_tables(note["content"], filename, note_uuid)
            self.note_cache_links(note)
            if note["changes"] > 0:
                self.write_note(filename, note)
            # Reassemble the note  XXX can be removed:
            # note_reassembled = self.assemble_markdown(note["metadata"], note["content"])
            # if self.notes_differ(note_text, note_reassembled) > 0:
            #     self.log.error(f"Error reassembling note from {filename}")
            #     return None
        return note

    def register_note(self, note_filename, note):
        note_file_title = os.path.basename(note_filename)[:-3].lower()
        if note_file_title in self.note_file_title_to_filename:
            self.log.error(
                f"Duplicate note basename {note_file_title} encountered at {note_filename}, ignoring note, please rename!"
            )
            return
        if note is not None:
            if "metadata" in note and "uuid" in note["metadata"]:
                uuid = note["metadata"]["uuid"]
                if uuid in self.uuid_to_note_filename:
                    self.log.error(
                        f"Duplicate uuid {uuid} encountered at {note_filename}, ignoring note, please make UUID unique!"
                    )
                    return
                self.uuid_to_note_filename[uuid] = note_filename
            self.note_file_title_to_filename[note_file_title] = note_filename
            self.notes[note_filename] = note

    def write_note(self, filename, note):
        if "metadata" not in note:
            self.log.error(f"Note {filename} has no metadata")
            return False
        if "content" not in note:
            self.log.error(f"Note {filename} has no content")
            return False
        note_reassembled = self.assemble_markdown(note["metadata"], note["content"])
        if self.dry_run is False:
            with open(filename, "w") as f:
                f.write(note_reassembled)
            self.log.info(f"Note {filename} written")
        else:
            self.log.warning(f"Dry run: Note {filename} would be written")
        return True

    def read_notes(self, skip_dirs, progress=False):
        self.notes = {}
        self.uuid_to_note_filename = {}
        self.note_file_title_to_filename = {}

        if progress is True:
            notes_count = 0
            for root, dirs, files in os.walk(self.notes_folder):
                for skip_dir in skip_dirs:
                    if skip_dir in dirs:
                        dirs.remove(skip_dir)
                for file in files:
                    if file.endswith(".md"):
                        notes_count += 1
            if notes_count == 0:
                self.log.info("No markdown notes found")
                return
            notes_progress = 0
        num = 0
        for root, dirs, files in os.walk(self.notes_folder):
            for skip_dir in skip_dirs:
                if skip_dir in dirs:
                    dirs.remove(skip_dir)
            for file in files:
                num += 1
                if file.endswith(".md"):
                    if progress is True:
                        notes_progress += 1
                        progress_str = progress_bar_string(
                            notes_progress, notes_count, bar_length=20
                        )
                        print(
                            f"\r{progress_str} {notes_progress}/{notes_count}", end=""
                        )

                    note_filename = os.path.join(root, file)
                    note = self.read_md_file(note_filename)
                    if note is not None:
                        self.register_note(note_filename, note)

        self.log.info(f"Found {len(self.notes)} existing markdown notes")
        return

    # def get_books(self):
    #     self.books = []
    #     for root, dirs, files in os.walk(self.notes_books_folder):
    #         for file in files:
    #             if file.endswith(".md"):
    #                 self.books.append(os.path.join(root, file))
    #     self.log.info(f"Found {len(self.books)} existing markdown notes on books")
    #     return self.books

    def rename_note(
        self, current_filename, new_filename, update_links=True, dry_run=False
    ):
        if current_filename not in self.notes:
            self.log.error(f"Note {current_filename} not found")
            return
        note = self.notes[current_filename]
        if new_filename in self.notes:
            self.log.error(f"Note {new_filename} already exists")
            return
        self.notes[new_filename] = note
        if dry_run is False:
            del self.notes[current_filename]
            os.rename(current_filename, new_filename)
            self.log.info(f"Note {current_filename} renamed to {new_filename}")
        else:
            self.log.info(
                f"Dry run: Note {current_filename} would be renamed to {new_filename}"
            )
        content_updates = 0
        if update_links is True:
            # Update links of format [[old_link]] or [[old_link|alias]] using regex links are case-insensitive
            old_link = os.path.basename(current_filename)[:-3].lower()
            new_link = os.path.basename(new_filename)[:-3]

            for note_filename in self.notes:
                note = self.notes[note_filename]
                if "content" in note:
                    content = note["content"]
                    new_content = []
                    note_updated = False
                    for line in content.split("\n"):
                        test_line = line.lower()
                        ind1 = test_line.find("[[")
                        if ind1 >= 0:
                            while ind1 >= 0:
                                ind2a = test_line.find("]]", ind1)
                                ind2b = test_line.find("|", ind1)
                                if ind2a <= 0:
                                    ind1 = test_line.find("[[", ind1 + 2)
                                    continue
                                if ind2b > 0 and ind2b < ind2a:
                                    ind2 = ind2b
                                else:
                                    ind2 = ind2a
                                link = test_line[ind1 + 2 : ind2].strip()
                                if link == old_link:
                                    self.log.info(
                                        f"Found link {link} in {note_filename}"
                                    )
                                    new_line = (
                                        line[:ind1] + "[[" + new_link + line[ind2:]
                                    )
                                    line = new_line
                                    test_line = line.lower()
                                    ind2 = ind1 + len(new_link) + 4
                                    note_updated = True
                                    if dry_run is False:
                                        self.log.info(
                                            f"Changed link {link} to {new_link} in {note_filename}:"
                                        )
                                        self.log.info(f"  {line} -> {new_line}")
                                    else:
                                        self.log.info(
                                            f"WOULD Change link {link} to {new_link} in {note_filename}:"
                                        )
                                        self.log.info(f"  {line} -> {new_line}")
                                ind1 = test_line.find("[[", ind2)
                            new_content.append(line)
                        else:
                            new_content.append(line)
                    if note_updated is True:
                        content_updates += 1
                        note["content"] = "\n".join(new_content) + "\n"
                        self.note_cache_links(note)
                        self.write_note(note_filename, note)
        return content_updates

    def md_filename(self, name):
        name = sanitized_md_filename(name)
        md_book_note_filename = os.path.join(self.notes_books_folder, name + ".md")
        return md_book_note_filename

    def md_annotation_filename(self, name):
        name = sanitized_md_filename(name)
        annotations_filename = os.path.join(
            self.notes_annotations_folder, "Notes on " + name
        )
        return annotations_filename

    def match_md_note_filename(self, md_book_note_filename):
        for book in self.books:
            if md_book_note_filename == book:
                self.log.info(f"exact match: {md_book_note_filename}")
                return md_book_note_filename
        # for book in self.books:
        #     if (
        #         md_note_filename[:-3] == book[: len(md_note_filename[:-3])]
        #         or md_note_filename[: len(book[:-3])] == book[:-3]
        #     ):
        #         self.log.info(
        #             f"Warning: Book filename {md_note_filename} does not match {book} exactly"
        #         )
        #         return book
        self.log.info(f"no match: {md_book_note_filename}")
        return None

    @staticmethod
    def gen_markdown_header(clip):
        md = ""
        md += f"# Notes on {clip['title']}\n\n"
        md += f"_by {clip['author']}_\n\n"
        ref = os.path.basename(clip["md_filename"])[:-3]
        ref = ref.split(",")[0]
        md += f"see [[{ref}]]\n\n"
        if clip["warning"] is not None:
            md += f"Warning: {clip['warning']}\n\n"
        return md

    def markdownify_clips(self, clips):
        md = ""
        for clip in clips:
            hd = MdTools.gen_markdown_header(clip)
            if os.path.exists(clip["notes_filename"]):
                print(f"File {clip['notes_filename']} already exists")
                with open(clip["notes_filename"], "r") as f:
                    md = f.read()
                if hd not in md:
                    print(
                        f"Incompatible notes header for {clip['notes_filename']}, keeping old header!"
                    )
                is_existing = True
            else:
                md = hd
                is_existing = False
            if "page" in clip and clip["page"] is not None:
                sub_header = f"### {clip['type']} on page {clip['page']}\n\n"
            else:
                sub_header = f"### {clip['type']} at location {clip['location']}\n\n"
            if is_existing and sub_header in md:
                print(f"Entry {sub_header} already exists in {clip['notes_filename']}")
                continue

            md += sub_header
            md += f"_on {clip['date']}:_\n\n"
            md += f"> {clip['content']}\n\n"
            with open(clip["notes_filename"], "w") as f:
                f.write(md)

    def notes_differ(
        self,
        old_note,
        new_note,
        check_frontmatter=True,
        check_content=True,
        verbose=True,
    ):
        old_note, changed1 = self._repairYaml(old_note)
        # if changed1 > 0:
        #     self.log.warning(f"YAML repaired in old_note")
        old_fm, old_content = self.parse_frontmatter(old_note)
        new_fm, new_content = self.parse_frontmatter(new_note)

        diffs = 0
        if check_frontmatter is True:
            key_set = set(old_fm.keys()).union(set(new_fm.keys()))
            for key in key_set:
                if key not in old_fm:
                    if verbose is True:
                        print("Existing note does not have key", key)
                    diffs += 1
                    continue
                if key not in new_fm:
                    if verbose is True:
                        print("New note does not have key", key)
                    diffs += 1
                    continue
                if old_fm[key] != new_fm[key]:
                    if verbose is True:
                        print(f"Key {key} differs: {old_fm[key]} vs {new_fm[key]}")
                    diffs += 1
                    continue
        if check_content is True:
            if old_content.strip() != new_content.strip():
                if verbose is True:
                    print(
                        f"Content differs, length: {len(old_content)} vs {len(new_content)}"
                    )
                diffs += 1
        if verbose is True:
            if diffs > 0:
                print(f"Found {diffs} differences\n")
        return diffs
