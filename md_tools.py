import os
import logging
import copy
import yaml  # type: ignore

from ebook_utils import sanitized_md_filename, progress_bar_string


class MdTools:
    """Class to manage the markdown folder of book records

    These markdown files have been generated by the calibre_tools export function.
    """

    def __init__(
        self,
        notes_folder,
        notes_books_folder=None,
        notes_annotations_folder=None,
        skip_dirs=[".obsidian"],
        progress=False,
    ):
        self.log = logging.getLogger("MdTools")
        self.notes_folder = notes_folder
        if notes_books_folder is None:
            notes_books_folder = os.path.join(notes_folder, "Books")
        if notes_annotations_folder is None:
            notes_annotations_folder = os.path.join(notes_folder, "BookNotes")
        self.notes_books_folder = notes_books_folder
        self.notes_annotations_folder = notes_annotations_folder
        self.skip_dirs = skip_dirs
        if not os.path.exists(self.notes_folder):
            raise FileNotFoundError(f"Notes folder {self.notes_folder} does not exist")
        if not os.path.exists(self.notes_books_folder):
            os.makedirs(self.notes_books_folder)
            self.log.info(f"Created folder {self.notes_books_folder}")
        if not os.path.exists(self.notes_annotations_folder):
            os.makedirs(self.notes_annotations_folder)
            self.log.info(f"Created folder {self.notes_annotations_folder}")
        self.progress = progress
        self.read_notes(skip_dirs=skip_dirs, progress=progress)

    def _repairYaml(self, txt):
        lines = txt.split("\n")
        in_front = False
        changed = 0
        header_end = None
        for ind, line in enumerate(lines):
            oldline = copy.copy(line)
            if in_front is False:
                if line == "---":
                    in_front = True
                else:
                    return txt, False
            else:
                if line == "---":
                    header_end = ind
                    break
                else:
                    while ":  " in line:
                        line = line.replace(":  ", ": ")
                        lines[ind] = line
                        changed += 1
                    fields = ["title", "title_sort"]
                    for field in fields:
                        tok = field + ": "
                        tokf = tok + '"'
                        if line.startswith(tok):
                            if line.startswith(tokf):
                                continue
                            else:
                                val = line[len(tok) :]
                                val = val.replace('"', "'")

                                line = tokf + val + '"'
                                lines[ind] = line
                                # print(f"REPAIR: {oldline}->{lines[ind]}")
                                changed += 1
                    t_fields = ["creation", "modification", "pubdate"]
                    for field in t_fields:
                        tok = field + ": "
                        if line.startswith(tok):
                            val = line[len(tok) :]
                            if "T" in val:
                                val = val.replace("T", " ")
                                line = tok + val
                                lines[ind] = line
                                changed += 1
                            if val.endswith("Z"):
                                val = val[:-1] + "+00:00"
                                line = tok + val
                                lines[ind] = line
                                changed += 1
                    if line.startswith(" -"):
                        line = " " + line
                        lines[ind] = line
                        changed += 1
                    if line.startswith("- "):
                        line = "  " + line
                        lines[ind] = line
                        changed += 1
                    if line.endswith(" "):
                        line = line.strip()
                        lines[ind] = line
                        changed += 1
        if header_end is not None and header_end < len(lines) - 1:
            if lines[header_end + 1] != "":
                # Insert empty line after header
                lines.insert(header_end + 1, "")
                changed += 1
        if changed > 0:
            txt = "\n".join(lines) + "\n"
        return txt, changed

    def parse_frontmatter(self, txt):
        state = 0
        lines = txt.split("\n")
        frontmatter = []
        content = []
        start = True
        for line in lines:
            if state == 0:
                if line == "---" and start is True:
                    state = 1
                else:
                    content.append(line)
                start = False
            elif state == 1:
                if line == "---":
                    state = 2
                else:
                    frontmatter.append(line)
            elif state == 2:
                if len(content) == 0:
                    if line == "":
                        continue
                content.append(line)
        frontmatter = "\n".join(frontmatter)  # + "\n"
        content = "\n".join(content) + "\n"
        try:
            metadata = yaml.safe_load(frontmatter)
            if metadata is None:
                metadata = {}
        except Exception as e:
            self.log.error(f"Error parsing frontmatter: {e}")
            metadata = {}
        return metadata, content

    def assemble_markdown(self, metadata, content):
        if metadata is None or metadata == {}:
            return content
        header = yaml.dump(metadata, default_flow_style=False, indent=2)
        return f"---\n{header}---\n\n{content}"

    def note_cache_links(self, note):
        links = []
        if "content" in note:
            content = note["content"]
            for line in content.split("\n"):
                # Find links of format [[link]] or [[link|alias]]
                ind = line.find("[[")
                while ind >= 0:
                    ind2a = line.find("]]", ind)
                    ind2b = line.find("|", ind)
                    if ind2a <= 0:
                        ind = line.find("[[", ind + 2)
                        continue
                    if ind2b > 0 and ind2b < ind2a:
                        ind2 = ind2b
                    else:
                        ind2 = ind2a
                    link = line[ind + 2 : ind2].strip().lower()
                    links.append(link)
                    ind = line.find("[[", ind2)
            note["links"] = links
        return links

    # Look for tables in markdown content. The last comment before the table can contain metadata
    # in form: `<!-- key1: value1; key2: value2; ... -->`
    # Returns a dict with tables, each table is a dict with columns and data and metadata
    ### XXX Frickel-Parser!
    def parse_tables(self, content, filepath, note_uuid=None):
        tables = []
        lines = content.split("\n")
        table_state = 0
        rows = []
        columns = []
        metadata = {}
        for line in lines:
            line = line.strip()
            # XXX sloppy parser, fails on ;: at wrong places!
            if "<!--" in line:
                metadata = {}
                try:
                    meta = line.split("<!--")[1].split("-->")[0]
                except:
                    meta = ""
                if len(meta) > 0:
                    metas = [mt.strip() for mt in meta.split(";")]
                    for mt in metas:
                        key = None
                        value = None
                        if ":" in mt:
                            try:
                                key, value = mt.split(":", 1)
                                metadata[key.strip()] = value.strip()
                            except:
                                pass

            if table_state == 0:
                if line.startswith("```"):
                    table_state = 4
                    continue
                if line.startswith("$$"):  # start of latex block
                    table_state = 5
                    continue
                if line.startswith("|"):
                    if not line.endswith("|"):
                        print(
                            f"Table line does not end with '|', >{line}<, malformed tabled! Ignoring data."
                        )
                        return tables
                    table_state = 1
                    columns = [col.strip() for col in line[1:].split("|")][:-1]
            elif table_state == 1:
                if line.startswith("|"):
                    for c in line:
                        if c not in ["|", " ", "-", ":", ">", "<"]:
                            table_state = 0
                            columns = []
                            rows = []
                            metadata = {}
                            continue
                    table_state = 2
                else:
                    columns = []
                    rows = []
                    metadata = {}
                    table_state = 0
            elif table_state == 2:
                if line.startswith("|"):
                    rows.append([col.strip() for col in line[1:].split("|")][:-1])
                else:
                    table_state = 0
                    if filepath.startswith(self.notes_folder):
                        subfolders = filepath[len(self.notes_folder) + 1 :]
                    else:
                        self.log.error(
                            f"Unexpected filepath {filepath} not in notes folder {self.notes_folder}"
                        )
                        subfolders = ""
                    if len(rows) > 0:
                        if "domain" not in metadata:
                            if subfolders == "":
                                subfolders == "books"
                            metadata["domain"] = f"{subfolders}"
                        table_entry = {
                            "columns": columns,
                            "rows": rows,
                            "metadata": metadata,
                        }
                        if note_uuid is not None:
                            table_entry["note_uuid"] = note_uuid
                        tables.append(table_entry)
                    rows = []
                    columns = []
                    metadata = {}
            elif table_state == 4:
                if line.startswith("```"):
                    table_state = 0
            elif table_state == 5:
                if line.startswith("$$"):  # end of latex block
                    table_state = 0
        return tables

    def read_md_file(self, filename, verbose=False):
        with open(filename, "r") as f:
            note_raw = f.read()
            note_text, changed = self._repairYaml(note_raw)
            note_text_s = note_text.strip()
            if note_text_s != note_text:
                if verbose is True:
                    self.log.warning(f"File stripped: {filename}")
                changed += 1
                note_text = note_text_s
            if changed > 0:
                if verbose is True:
                    self.log.warning(f"YAML repaired in {filename}")
            note = {}
            note["metadata_changes"] = changed
            note["metadata"], note["content"] = self.parse_frontmatter(note_text)
            if "uuid" in note["metadata"]:
                note_uuid = note["metadata"]["uuid"]
            else:
                note_uuid = None
            note["tables"] = self.parse_tables(note["content"], filename, note_uuid)
            self.note_cache_links(note)
            # Reassemble the note  XXX can be removed:
            note_reassembled = self.assemble_markdown(note["metadata"], note["content"])
            if self.notes_differ(note_text, note_reassembled) > 0:
                self.log.error(f"Error reassembling note from {filename}")
                return None
        return note

    def register_note(self, note_filename, note):
        note_file_title = os.path.basename(note_filename)[:-3].lower()
        if note_file_title in self.note_file_title_to_filename:
            self.log.error(
                f"Duplicate note basename {note_file_title} encountered at {note_filename}, ignoring note, please rename!"
            )
            return
        if note is not None:
            if "metadata" in note and "uuid" in note["metadata"]:
                uuid = note["metadata"]["uuid"]
                if uuid in self.uuid_to_note_filename:
                    self.log.error(
                        f"Duplicate uuid {uuid} encountered at {note_filename}, ignoring note, please make UUID unique!"
                    )
                    return
                self.uuid_to_note_filename[uuid] = note_filename
            self.note_file_title_to_filename[note_file_title] = note_filename
            self.notes[note_filename] = note

    def read_notes(self, skip_dirs=[".obsidian"], progress=False):
        self.notes = {}
        self.uuid_to_note_filename = {}
        self.note_file_title_to_filename = {}

        if progress is True:
            notes_count = 0
            for root, dirs, files in os.walk(self.notes_folder):
                for skip_dir in skip_dirs:
                    if skip_dir in dirs:
                        dirs.remove(skip_dir)
                for file in files:
                    if file.endswith(".md"):
                        notes_count += 1
            if notes_count == 0:
                self.log.info(f"No markdown notes found")
                return
            notes_progress = 0
        for root, dirs, files in os.walk(self.notes_folder):
            for skip_dir in skip_dirs:
                if skip_dir in dirs:
                    dirs.remove(skip_dir)

            for file in files:
                if file.endswith(".md"):

                    if progress is True:
                        notes_progress += 1
                        progress_str = progress_bar_string(
                            notes_progress, notes_count, bar_length=20
                        )
                        print(
                            f"\r{progress_str} {notes_progress}/{notes_count}", end=""
                        )

                    note_filename = os.path.join(root, file)
                    note = self.read_md_file(note_filename)
                    if note is not None:
                        self.register_note(note_filename, note)

        self.log.info(f"Found {len(self.notes)} existing markdown notes")
        return

    # def get_books(self):
    #     self.books = []
    #     for root, dirs, files in os.walk(self.notes_books_folder):
    #         for file in files:
    #             if file.endswith(".md"):
    #                 self.books.append(os.path.join(root, file))
    #     self.log.info(f"Found {len(self.books)} existing markdown notes on books")
    #     return self.books

    def rename_note(
        self, current_filename, new_filename, update_links=True, dry_run=False
    ):
        if current_filename not in self.notes:
            self.log.error(f"Note {current_filename} not found")
            return
        note = self.notes[current_filename]
        if new_filename in self.notes:
            self.log.error(f"Note {new_filename} already exists")
            return
        self.notes[new_filename] = note
        if dry_run is False:
            del self.notes[current_filename]
            os.rename(current_filename, new_filename)
            self.log.info(f"Note {current_filename} renamed to {new_filename}")
        else:
            self.log.info(
                f"Dry run: Note {current_filename} would be renamed to {new_filename}"
            )
        content_updates = 0
        if update_links is True:
            # Update links of format [[old_link]] or [[old_link|alias]] using regex links are case-insensitive
            old_link = os.path.basename(current_filename)[:-3].lower()
            new_link = os.path.basename(new_filename)[:-3]

            for note_filename in self.notes:
                note = self.notes[note_filename]
                if "content" in note:
                    content = note["content"]
                    new_content = []
                    note_updated = False
                    for line in content.split("\n"):
                        test_line = line.lower()
                        ind1 = test_line.find("[[")
                        if ind1 >= 0:
                            while ind1 >= 0:
                                ind2a = test_line.find("]]", ind1)
                                ind2b = test_line.find("|", ind1)
                                if ind2a <= 0:
                                    ind1 = test_line.find("[[", ind1 + 2)
                                    continue
                                if ind2b > 0 and ind2b < ind2a:
                                    ind2 = ind2b
                                else:
                                    ind2 = ind2a
                                link = test_line[ind1 + 2 : ind2].strip()
                                if link == old_link:
                                    self.log.info(
                                        f"Found link {link} in {note_filename}"
                                    )
                                    new_line = (
                                        line[:ind1] + "[[" + new_link + line[ind2:]
                                    )
                                    line = new_line
                                    test_line = line.lower()
                                    ind2 = ind1 + len(new_link) + 4
                                    note_updated = True
                                    if dry_run is False:
                                        self.log.info(
                                            f"Changed link {link} to {new_link} in {note_filename}:"
                                        )
                                        self.log.info(f"  {line} -> {new_line}")
                                    else:
                                        self.log.info(
                                            f"WOULD Change link {link} to {new_link} in {note_filename}:"
                                        )
                                        self.log.info(f"  {line} -> {new_line}")
                                ind1 = test_line.find("[[", ind2)
                            new_content.append(line)
                        else:
                            new_content.append(line)
                    if note_updated is True:
                        content_updates += 1
                        note["content"] = "\n".join(new_content) + "\n"
                        self.note_cache_links(note)
                        note_reassembled = self.assemble_markdown(
                            note["metadata"], note["content"]
                        )
                        if dry_run is False:
                            with open(note_filename, "w") as f:
                                f.write(note_reassembled)
                            self.log.info(f"Note {note_filename} updated")
                        else:
                            self.log.info(
                                f"Dry run: Note {note_filename} would be updated"
                            )
        return content_updates

    def md_filename(self, name):
        name = sanitized_md_filename(name)
        md_book_note_filename = os.path.join(self.notes_books_folder, name + ".md")
        return md_book_note_filename

    def md_annotation_filename(self, name):
        name = sanitized_md_filename(name)
        annotations_filename = os.path.join(
            self.notes_annotations_folder, "Notes on " + name
        )
        return annotations_filename

    def match_md_note_filename(self, md_book_note_filename):
        for book in self.books:
            if md_book_note_filename == book:
                self.log.info(f"exact match: {md_book_note_filename}")
                return md_book_note_filename
        # for book in self.books:
        #     if (
        #         md_note_filename[:-3] == book[: len(md_note_filename[:-3])]
        #         or md_note_filename[: len(book[:-3])] == book[:-3]
        #     ):
        #         self.log.info(
        #             f"Warning: Book filename {md_note_filename} does not match {book} exactly"
        #         )
        #         return book
        self.log.info(f"no match: {md_book_note_filename}")
        return None

    @staticmethod
    def gen_markdown_header(clip):
        md = ""
        md += f"# Notes on {clip['title']}\n\n"
        md += f"_by {clip['author']}_\n\n"
        ref = os.path.basename(clip["md_filename"])[:-3]
        ref = ref.split(",")[0]
        md += f"see [[{ref}]]\n\n"
        if clip["warning"] is not None:
            md += f"Warning: {clip['warning']}\n\n"
        return md

    def markdownify_clips(self, clips):
        md = ""
        for clip in clips:
            hd = MdTools.gen_markdown_header(clip)
            if os.path.exists(clip["notes_filename"]):
                print(f"File {clip['notes_filename']} already exists")
                with open(clip["notes_filename"], "r") as f:
                    md = f.read()
                if hd not in md:
                    print(
                        f"Incompatible notes header for {clip['notes_filename']}, keeping old header!"
                    )
                is_existing = True
            else:
                md = hd
                is_existing = False
            if "page" in clip and clip["page"] is not None:
                sub_header = f"### {clip['type']} on page {clip['page']}\n\n"
            else:
                sub_header = f"### {clip['type']} at location {clip['location']}\n\n"
            if is_existing and sub_header in md:
                print(f"Entry {sub_header} already exists in {clip['notes_filename']}")
                continue

            md += sub_header
            md += f"_on {clip['date']}:_\n\n"
            md += f"> {clip['content']}\n\n"
            with open(clip["notes_filename"], "w") as f:
                f.write(md)

    def notes_differ(
        self,
        old_note,
        new_note,
        check_frontmatter=True,
        check_content=True,
        verbose=True,
    ):
        old_note, changed1 = self._repairYaml(old_note)
        # if changed1 > 0:
        #     self.log.warning(f"YAML repaired in old_note")
        old_fm, old_content = self.parse_frontmatter(old_note)
        new_fm, new_content = self.parse_frontmatter(new_note)

        diffs = 0
        if check_frontmatter is True:
            key_set = set(old_fm.keys()).union(set(new_fm.keys()))
            for key in key_set:
                if key not in old_fm:
                    if verbose is True:
                        print("Existing note does not have key", key)
                    diffs += 1
                    continue
                if key not in new_fm:
                    if verbose is True:
                        print("New note does not have key", key)
                    diffs += 1
                    continue
                if old_fm[key] != new_fm[key]:
                    if verbose is True:
                        print(f"Key {key} differs: {old_fm[key]} vs {new_fm[key]}")
                    diffs += 1
                    continue
        if check_content is True:
            if old_content.strip() != new_content.strip():
                if verbose is True:
                    print(
                        f"Content differs, length: {len(old_content)} vs {len(new_content)}"
                    )
                diffs += 1
        if verbose is True:
            if diffs > 0:
                print(f"Found {diffs} differences\n")
        return diffs
