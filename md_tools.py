import os
import logging
import copy
import yaml

from ebook_utils import sanitized_md_filename


class MdTools:
    """Class to manage the markdown folder of book records

    These markdown files have been generated by the calibre_tools export function.
    """

    def __init__(
        self, notes_folder, notes_books_folder=None, notes_annotations_folder=None
    ):
        self.log = logging.getLogger("MdTools")
        self.notes_folder = notes_folder
        if notes_books_folder is None:
            notes_books_folder = os.path.join(notes_folder, "Books")
        if notes_annotations_folder is None:
            notes_annotations_folder = os.path.join(notes_folder, "BookNotes")
        self.notes_books_folder = notes_books_folder
        self.notes_annotations_folder = notes_annotations_folder
        if not os.path.exists(self.notes_folder):
            raise FileNotFoundError(f"Notes folder {self.notes_folder} does not exist")
        if not os.path.exists(self.notes_books_folder):
            os.makedirs(self.notes_books_folder)
            self.log.info(f"Created folder {self.notes_books_folder}")
        if not os.path.exists(self.notes_annotations_folder):
            os.makedirs(self.notes_annotations_folder)
            self.log.info(f"Created folder {self.notes_annotations_folder}")

    def _repairYaml(self, txt):
        lines = txt.split("\n")
        in_front = False
        changed = 0
        header_end = None
        for ind, line in enumerate(lines):
            oldline = copy.copy(line)
            if in_front is False:
                if line == "---":
                    in_front = True
                else:
                    return txt, False
            else:
                if line == "---":
                    header_end = ind
                    break
                else:
                    while ":  " in line:
                        line = line.replace(":  ", ": ")
                        lines[ind] = line
                        changed += 1
                    fields = ["title", "title_sort"]
                    for field in fields:
                        tok = field + ": "
                        tokf = tok + '"'
                        if line.startswith(tok):
                            if line.startswith(tokf):
                                continue
                            else:
                                val = line[len(tok) :]
                                val = val.replace('"', "'")

                                line = tokf + val + '"'
                                lines[ind] = line
                                # print(f"REPAIR: {oldline}->{lines[ind]}")
                                changed += 1
                    t_fields = ["creation", "modification", "pubdate"]
                    for field in t_fields:
                        tok = field + ": "
                        if line.startswith(tok):
                            val = line[len(tok) :]
                            if "T" in val:
                                val = val.replace("T", " ")
                                line = tok + val
                                lines[ind] = line
                                changed += 1
                            if val.endswith("Z"):
                                val = val[:-1] + "+00:00"
                                line = tok + val
                                lines[ind] = line
                                changed += 1
                    if line.startswith(" -"):
                        line = " " + line
                        lines[ind] = line
                        changed += 1
                    if line.startswith("- "):
                        line = "  " + line
                        lines[ind] = line
                        changed += 1
                    if line.endswith(" "):
                        line = line.strip()
                        lines[ind] = line
                        changed += 1
        if header_end is not None and header_end < len(lines) - 1:
            if lines[header_end + 1] != "":
                # Insert empty line after header
                lines.insert(header_end + 1, "")
                changed += 1
        if changed > 0:
            txt = "\n".join(lines)
        return txt, changed

    def parse_frontmatter(self, txt):
        state = 0
        lines = txt.split("\n")
        frontmatter = []
        content = []
        start = True
        for line in lines:
            if state == 0:
                if line == "---" and start is True:
                    state = 1
                else:
                    content.append(line)
                start = False
            elif state == 1:
                if line == "---":
                    state = 2
                else:
                    frontmatter.append(line)
            elif state == 2:
                content.append(line)
        frontmatter = "\n".join(frontmatter)
        content = "\n".join(content)
        try:
            metadata = yaml.safe_load(frontmatter)
            if metadata is None:
                metadata = {}
        except Exception as e:
            self.log.error(f"Error parsing frontmatter: {e}")
            metadata = {}
        return metadata, content

    def assemble_markdown(self, metadata, content):
        if metadata is None or metadata == {}:
            return content
        header = yaml.dump(metadata, default_flow_style=False, indent=2)
        return f"---\n{header}---\n{content}"

    def read_md_file(self, filename, verbose=False):
        with open(filename, "r") as f:
            note_raw = f.read()
            note_text, changed = self._repairYaml(note_raw)
            note_text_s = note_text.strip()
            if note_text_s != note_text:
                if verbose is True:
                    self.log.warning(f"File stripped: {filename}")
                changed += 1
                note_text = note_text_s
            if changed > 0:
                if verbose is True:
                    self.log.warning(f"YAML repaired in {filename}")
            note = {}

            note["metadata"], note["content"] = self.parse_frontmatter(note_text)
            # Reassemble the note

            note_reassembled = self.assemble_markdown(note["metadata"], note["content"])
            if self.notes_differ(note_text, note_reassembled) > 0:
                self.log.error(f"Error reassembling note from {filename}")
                return None
        return note

    def read_notes(self, skip_dirs=[".obsidian"]):
        self.notes = {}

        for root, dirs, files in os.walk(self.notes_folder):
            for skip_dir in skip_dirs:
                if skip_dir in dirs:
                    dirs.remove(skip_dir)

            for file in files:
                if file.endswith(".md"):
                    note_filename = os.path.join(root, file)
                    note = self.read_md_file(note_filename)
                    if note is not None:
                        self.notes[note_filename] = note
        self.log.info(f"Found {len(self.notes)} existing markdown notes")
        return

    def get_books(self):
        self.books = []
        for root, dirs, files in os.walk(self.notes_books_folder):
            for file in files:
                if file.endswith(".md"):
                    self.books.append(os.path.join(root, file))
        self.log.info(f"Found {len(self.books)} existing markdown notes on books")
        return self.books

    def md_filename(self, name):
        name = sanitized_md_filename(name)
        md_book_note_filename = os.path.join(self.notes_books_folder, name + ".md")
        return md_book_note_filename

    def md_annotation_filename(self, name):
        name = sanitized_md_filename(name)
        annotations_filename = os.path.join(
            self.notes_annotations_folder, "Notes on " + name
        )
        return annotations_filename

    def match_md_note_filename(self, md_book_note_filename):
        for book in self.books:
            if md_book_note_filename == book:
                self.log.info(f"exact match: {md_book_note_filename}")
                return md_book_note_filename
        # for book in self.books:
        #     if (
        #         md_note_filename[:-3] == book[: len(md_note_filename[:-3])]
        #         or md_note_filename[: len(book[:-3])] == book[:-3]
        #     ):
        #         self.log.info(
        #             f"Warning: Book filename {md_note_filename} does not match {book} exactly"
        #         )
        #         return book
        self.log.info(f"no match: {md_book_note_filename}")
        return None

    @staticmethod
    def gen_markdown_header(clip):
        md = ""
        md += f"# Notes on {clip['title']}\n\n"
        md += f"_by {clip['author']}_\n\n"
        ref = os.path.basename(clip["md_filename"])[:-3]
        ref = ref.split(",")[0]
        md += f"see [[{ref}]]\n\n"
        if clip["warning"] is not None:
            md += f"Warning: {clip['warning']}\n\n"
        return md

    def markdownify_clips(self, clips):
        md = ""
        for clip in clips:
            hd = MdTools.gen_markdown_header(clip)
            if os.path.exists(clip["notes_filename"]):
                print(f"File {clip['notes_filename']} already exists")
                with open(clip["notes_filename"], "r") as f:
                    md = f.read()
                if hd not in md:
                    print(
                        f"Incompatible notes header for {clip['notes_filename']}, keeping old header!"
                    )
                is_existing = True
            else:
                md = hd
                is_existing = False
            if "page" in clip and clip["page"] is not None:
                sub_header = f"### {clip['type']} on page {clip['page']}\n\n"
            else:
                sub_header = f"### {clip['type']} at location {clip['location']}\n\n"
            if is_existing and sub_header in md:
                print(f"Entry {sub_header} already exists in {clip['notes_filename']}")
                continue

            md += sub_header
            md += f"_on {clip['date']}:_\n\n"
            md += f"> {clip['content']}\n\n"
            with open(clip["notes_filename"], "w") as f:
                f.write(md)

    def notes_differ(
        self,
        old_note,
        new_note,
        check_frontmatter=True,
        check_content=True,
        verbose=False,
    ):
        old_note, changed1 = self._repairYaml(old_note)
        # if changed1 > 0:
        #     self.log.warning(f"YAML repaired in old_note")
        old_fm, old_content = self.parse_frontmatter(old_note)
        new_fm, new_content = self.parse_frontmatter(new_note)

        diffs = 0
        if check_frontmatter is True:

            key_set = set(old_fm.keys()).union(set(new_fm.keys()))
            for key in key_set:
                if key not in old_fm:
                    if verbose is True:
                        print("Existing note does not have key", key)
                    diffs += 1
                    continue
                if key not in new_fm:
                    if verbose is True:
                        print("New note does not have key", key)
                    diffs += 1
                    continue
                if old_fm[key] != new_fm[key]:
                    if verbose is True:
                        print(f"Key {key} differs: {old_fm[key]} vs {new_fm[key]}")
                    diffs += 1
                    continue
        if check_content is True:
            if old_content != new_content:
                if verbose is True:
                    print("Content differs")
                diffs += 1
        return diffs
